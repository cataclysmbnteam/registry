#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Generate plugin index files from manifests.
 * Creates JSON and Markdown outputs for API and documentation.
 * Note: Individual mod pages are generated by Lume directly from manifests.
 */

import { Command } from "@cliffy/command"
import { sortBy } from "@std/collections"
import * as YAML from "@std/yaml"
import { walk } from "@std/fs"
import { ModManifest } from "../schema/manifest.ts"
import { toJsonSchema } from "@valibot/to-json-schema"

const DEFAULT_ICON =
  "https://raw.githubusercontent.com/cataclysmbnteam/Cataclysm-BN/main/gfx/app_icon/app-icon.svg"

/**
 * Load all manifests from a directory.
 * Skips files starting with underscore (examples).
 */
export const loadManifests = async (
  manifestDir: string,
): Promise<ModManifest[]> => {
  const manifests: ModManifest[] = []

  for await (
    const entry of walk(manifestDir, {
      exts: [".yaml", ".yml", ".json"],
      includeDirs: false,
      maxDepth: 1,
    })
  ) {
    // Skip example files
    if (entry.name.startsWith("_")) continue

    try {
      const content = await Deno.readTextFile(entry.path)
      const manifest = YAML.parse(content) as ModManifest
      manifests.push(manifest)
    } catch (error) {
      console.error(`Error loading ${entry.path}: ${error}`)
    }
  }

  return manifests
}

/**
 * Generate combined JSON index.
 */
export const generateJsonIndex = (manifests: ModManifest[]): string => {
  const sorted = sortBy(manifests, (m) => m.display_name)
  return JSON.stringify(sorted, null, 2)
}

/**
 * Generate Markdown table of mods.
 */
export const generateMarkdownTable = (manifests: ModManifest[]): string => {
  const sorted = sortBy(manifests, (m) => m.display_name)

  let buffer = `# Cataclysm: Bright Nights Mod Registry

This is an automatically generated list of mods in the registry.

| | Name | Author | Version | Description |
|-|------|--------|---------|-------------|
`

  for (const mod of sorted) {
    const iconUrl = mod.icon_url ?? DEFAULT_ICON
    const downloadUrl = mod.source.url
    const description = mod.short_description.replace(/\|/g, "\\|").trim()

    buffer +=
      `| ![Icon](${iconUrl}) | [${mod.display_name}](${downloadUrl}) | ${mod.author} | ${mod.version} | ${description} |\n`
  }

  return buffer
}

/**
 * Generate OpenAPI 3.0 specification.
 */
export const generateOpenApiSpec = (): object => {
  const modSchema = toJsonSchema(ModManifest, { typeMode: "input", errorMode: "ignore" })

  return {
    openapi: "3.0.3",
    info: {
      title: "BN Mod Registry API",
      description:
        "API for accessing Cataclysm: Bright Nights mod metadata. This is a static JSON API - all data is served from pre-generated files.",
      version: "1.0.0",
      license: {
        name: "MIT",
        url: "https://opensource.org/licenses/MIT",
      },
    },
    servers: [
      {
        url: "https://cataclysmbnteam.github.io/registry",
        description: "Production",
      },
    ],
    paths: {
      "/generated/mods.json": {
        get: {
          summary: "Get all mods",
          description:
            "Returns an array of all mod manifests in the registry, sorted alphabetically by display name.",
          operationId: "getMods",
          tags: ["Mods"],
          responses: {
            "200": {
              description: "Successful response",
              content: {
                "application/json": {
                  schema: {
                    type: "array",
                    items: modSchema,
                  },
                },
              },
            },
          },
        },
      },
      "/generated/mods/{mod_id}.json": {
        get: {
          summary: "Get a single mod",
          description: "Returns the manifest for a specific mod by its ID.",
          operationId: "getMod",
          tags: ["Mods"],
          parameters: [
            {
              name: "mod_id",
              in: "path",
              required: true,
              description: "The unique identifier of the mod",
              schema: {
                type: "string",
                pattern: "^[a-z0-9][a-z0-9_-]*$",
              },
            },
          ],
          responses: {
            "200": {
              description: "Successful response",
              content: {
                "application/json": {
                  schema: modSchema,
                },
              },
            },
            "404": {
              description: "Mod not found",
            },
          },
        },
      },
    },
    components: {
      schemas: {
        ModManifest: modSchema,
      },
    },
  }
}

/**
 * Generate all output files (JSON index, Markdown table, OpenAPI spec, and individual mod files).
 */
export const generateAll = async (
  manifestDir: string,
  outputDir: string,
): Promise<void> => {
  // Ensure output directories exist
  await Deno.mkdir(outputDir, { recursive: true })
  await Deno.mkdir(`${outputDir}/mods`, { recursive: true })

  console.log(`Loading manifests from ${manifestDir}/`)
  const manifests = await loadManifests(manifestDir)
  console.log(`Found ${manifests.length} manifests`)

  // Generate individual mod JSON files
  console.log(`Generating individual mod JSON files...`)
  await Promise.all(
    manifests.map((mod) =>
      Deno.writeTextFile(
        `${outputDir}/mods/${mod.id}.json`,
        JSON.stringify(mod, null, 2),
      )
    ),
  )

  await Promise.all([
    Deno.writeTextFile(`${outputDir}/mods.json`, generateJsonIndex(manifests)),
    Deno.writeTextFile(`${outputDir}/mods.md`, generateMarkdownTable(manifests)),
    Deno.writeTextFile(
      `${outputDir}/mod_manifest.schema.json`,
      JSON.stringify(
        toJsonSchema(ModManifest, { typeMode: "input", errorMode: "ignore" }),
        null,
        2,
      ),
    ),
    Deno.writeTextFile(
      `${outputDir}/openapi.json`,
      JSON.stringify(generateOpenApiSpec(), null, 2),
    ),
  ])
}

// CLI entry point
if (import.meta.main) {
  await new Command()
    .name("generate")
    .version("1.0.0")
    .description("Generate index files from manifests (JSON and Markdown)")
    .arguments("[manifest-dir:string] [output-dir:string]")
    .action(async (_options, manifestDir = "manifests", outputDir = "generated") => {
      try {
        await generateAll(manifestDir, outputDir)
        console.log("\nDone!")
      } catch (error) {
        console.error(`Error: ${error}`)
        Deno.exit(1)
      }
    })
    .parse(Deno.args)
}
