#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Generate plugin index files from manifests.
 * Creates JSON and Markdown outputs for API and documentation.
 * Note: Individual mod pages are generated by Lume directly from manifests.
 */

import { Command } from "@cliffy/command"
import * as YAML from "@std/yaml"
import { walk } from "@std/fs"
import { ModManifest } from "../schema/manifest.ts"
import { toJsonSchema } from "@valibot/to-json-schema"

const DEFAULT_ICON =
  "https://raw.githubusercontent.com/cataclysmbnteam/Cataclysm-BN/main/gfx/app_icon/app-icon.svg"

/**
 * Load all manifests from a directory.
 * Skips files starting with underscore (examples).
 */
export const loadManifests = async (
  manifestDir: string,
): Promise<ModManifest[]> => {
  const manifests: ModManifest[] = []

  for await (
    const entry of walk(manifestDir, {
      exts: [".yaml", ".yml", ".json"],
      includeDirs: false,
      maxDepth: 1,
    })
  ) {
    // Skip example files
    if (entry.name.startsWith("_")) continue

    try {
      const content = await Deno.readTextFile(entry.path)
      const manifest = YAML.parse(content) as ModManifest
      manifests.push(manifest)
    } catch (error) {
      console.error(`Error loading ${entry.path}: ${error}`)
    }
  }

  return manifests
}

/**
 * Generate combined JSON index.
 */
export const generateJsonIndex = (manifests: ModManifest[]): string => {
  const sorted = [...manifests].sort((a, b) => a.display_name.localeCompare(b.display_name))
  return JSON.stringify(sorted, null, 2)
}

/**
 * Generate Markdown table of mods.
 */
export const generateMarkdownTable = (manifests: ModManifest[]): string => {
  const sorted = [...manifests].sort((a, b) => a.display_name.localeCompare(b.display_name))

  let buffer = `# Cataclysm: Bright Nights Mod Registry

This is an automatically generated list of mods in the registry.

| | Name | Author | Version | Description |
|-|------|--------|---------|-------------|
`

  for (const mod of sorted) {
    const iconUrl = mod.icon_url ?? DEFAULT_ICON
    const downloadUrl = mod.source.url
    const description = mod.short_description.replace(/\|/g, "\\|").trim()

    buffer +=
      `| ![Icon](${iconUrl}) | [${mod.display_name}](${downloadUrl}) | ${mod.author} | ${mod.version} | ${description} |\n`
  }

  return buffer
}

/**
 * Generate all output files (JSON index and Markdown table).
 */
export const generateAll = async (
  manifestDir: string,
  outputDir: string,
): Promise<void> => {
  // Ensure output directory exists
  await Deno.mkdir(outputDir, { recursive: true })

  console.log(`Loading manifests from ${manifestDir}/`)
  const manifests = await loadManifests(manifestDir)
  console.log(`Found ${manifests.length} manifests`)

  await Promise.all([
    await Deno.writeTextFile(`${outputDir}/mods.json`, generateJsonIndex(manifests)),
    await Deno.writeTextFile(`${outputDir}/mods.md`, generateMarkdownTable(manifests)),
    await Deno.writeTextFile(
      `${outputDir}/mod_manifest.schema.json`,
      JSON.stringify(
        toJsonSchema(ModManifest, { typeMode: "input", errorMode: "ignore" }),
        null,
        2,
      ),
    ),
  ])
}

// CLI entry point
if (import.meta.main) {
  await new Command()
    .name("generate")
    .version("1.0.0")
    .description("Generate index files from manifests (JSON and Markdown)")
    .arguments("[manifest-dir:string] [output-dir:string]")
    .action(async (_options, manifestDir = "manifests", outputDir = "generated") => {
      try {
        await generateAll(manifestDir, outputDir)
        console.log("\nDone!")
      } catch (error) {
        console.error(`Error: ${error}`)
        Deno.exit(1)
      }
    })
    .parse(Deno.args)
}
